#!/usr/bin/env python3
import argparse
import os
from typing import List, Tuple

import numpy as np
from scipy.interpolate import CubicSpline  # require SciPy


def parse_triplet(s: str) -> Tuple[float, float, float]:
    """
    Parse a string like:
      "(10, 0, 0.0)"
      "10 0 0.0"
      "10,0,0.0"
    into a (a, b, c) float triplet.
    """
    s = s.strip()
    if s and s[0] in "([{":
        s = s[1:]
    if s and s[-1] in ")]}":
        s = s[:-1]

    parts = [p for p in s.replace(",", " ").split() if p]
    if len(parts) != 3:
        raise ValueError(f"Could not parse triplet from '{s}' (need 3 numbers)")
    return float(parts[0]), float(parts[1]), float(parts[2])


def build_angle_interp(
    times: np.ndarray,
    angles_deg: np.ndarray,
    n_points: int,
) -> Tuple[np.ndarray, np.ndarray]:
    """
    Build a shortest-path, C^1-smooth interpolation for angles (in degrees).

    - Keep your keyframe times as-is (no time warping)
    - Convert angles to radians
    - np.unwrap -> shortest path on circle
    - CubicSpline(angle(t)) in radians with clamped BC
    - Evaluate on a uniform time grid between min(t) and max(t)
    - Return (tt, angles_deg(tt))
    """
    # Sort by time in case user passes unordered points
    order = np.argsort(times)
    t_sorted = times[order]
    a_sorted_deg = angles_deg[order]

    if len(t_sorted) < 2:
        raise ValueError("Need at least two keyframes to interpolate angles")

    t_min, t_max = float(t_sorted[0]), float(t_sorted[-1])
    tt = np.linspace(t_min, t_max, n_points)

    # degrees -> radians
    a_sorted_rad = np.radians(a_sorted_deg)

    # unwrap to enforce shortest-path continuity
    a_unwrapped_rad = np.unwrap(a_sorted_rad)

    # C^1-smooth interpolation angle(t)
    cs = CubicSpline(t_sorted, a_unwrapped_rad, bc_type="clamped")
    aa_rad = cs(tt)

    # back to degrees
    aa_deg = np.degrees(aa_rad)
    return tt, aa_deg


def write_rotation_dat(
    out_path: str,
    times: np.ndarray,
    rx_deg: np.ndarray,
    ry_deg: np.ndarray,
    origin: Tuple[float, float, float],
) -> None:
    """
    Write rotation.dat in the form:

      n
      (
      (t (rx ry rz))
      ...
      )

    Angles are in DEGREES and correspond to OpenFOAM's
    (rotX rotY rotZ) about the global axes.
    """
    ox, oy, oz = origin
    n_points = len(times)

    with open(out_path, "w") as f:
        f.write("// rotation.dat generated by make_motion_tables.py\n")
        f.write(f"// Origin / CofG (for reference): ({ox:.6f} {oy:.6f} {oz:.6f})\n")
        f.write(f"{n_points}\n(\n")
        for t, rx, ry in zip(times, rx_deg, ry_deg):
            f.write(f"({t:.6f} ({rx:.6f} {ry:.6f} 0.000000))\n")
        f.write(")\n")


def write_translation_dat(
    out_path: str,
    times: np.ndarray,
    origin: Tuple[float, float, float],
) -> None:
    """
    Write translation.dat in the form:

      n
      (
      (t (0 0 0))
      ...
      )

    Currently we write zero translation at all times.
    """
    ox, oy, oz = origin
    n_points = len(times)

    with open(out_path, "w") as f:
        f.write("// translation.dat generated by make_motion_tables.py\n")
        f.write(f"// Origin / CofG (for reference): ({ox:.6f} {oy:.6f} {oz:.6f})\n")
        f.write(f"{n_points}\n(\n")
        for t in times:
            f.write(f"({t:.6f} (0 0 0))\n")
        f.write(")\n")


def write_initial_orientation(
    out_path: str,
    rx0: float,
    ry0: float,
    origin: Tuple[float, float, float],
) -> None:
    """
    Write initialOrientation.dat with:

      line 1: rotX rotY rotZ (deg)  - ABSOLUTE FOAM angles at t=0
      line 2: CoGx CoGy CoGz (m)   - rotation center to use for pre-rotation

    The run script will:
      - translate by -CoG
      - rotate by rotX, rotY
      - translate back by +CoG
    """
    ox, oy, oz = origin
    with open(out_path, "w") as f:
        f.write("// Initial absolute orientation in FOAM angles (deg)\n")
        f.write("// rotX rotY rotZ\n")
        f.write(f"{rx0:.6f} {ry0:.6f} 0.000000\n")
        f.write("// Rotation centre (CoG) in meters\n")
        f.write("// CoGx CoGy CoGz\n")
        f.write(f"{ox:.6f} {oy:.6f} {oz:.6f}\n")


def main(argv: List[str] = None) -> None:
    parser = argparse.ArgumentParser(
        description=(
            "Generate OpenFOAM rotation.dat and translation.dat from "
            "keyframe angles given in your notation, using shortest-path "
            "cubic splines for smooth human-like motion, and emitting an "
            "initialOrientation.dat for pre-rotating the mesh about CoG."
        )
    )

    parser.add_argument(
        "--points",
        metavar="(H_x,H_y,t)",
        type=str,
        nargs="+",
        required=True,
        help=(
            "Keyframes as triplets (head_x_deg, head_y_deg, time_s) in YOUR notation. "
            "Example: --points '(285,0,0.0)' '(180,0,0.16)' '(75,0,0.4)'"
        ),
    )

    parser.add_argument(
        "--origin",
        metavar="(x,y,z)",
        type=str,
        required=True,
        help=(
            "Origin / CofG for the motion, in meters, "
            "same coordinates as OpenFOAM (must match dynamicMeshDict). "
            "Example: --origin '(0,0,0.10)'"
        ),
    )

    parser.add_argument(
        "--output_dir",
        type=str,
        required=True,
        help="Directory where rotation.dat, translation.dat, initialOrientation.dat will be written.",
    )

    parser.add_argument(
        "--n_points",
        type=int,
        default=200,
        help="Number of samples in the generated tables (default: 200).",
    )

    args = parser.parse_args(argv)

    # Parse origin
    ox, oy, oz = parse_triplet(args.origin)
    origin = (ox, oy, oz)

    # Parse keyframe points: YOUR head angles H_x, H_y
    Hx_list = []
    Hy_list = []
    t_list = []

    for s in args.points:
        Hx, Hy, t = parse_triplet(s)
        Hx_list.append(Hx)
        Hy_list.append(Hy)
        t_list.append(t)

    Hx_arr = np.array(Hx_list, dtype=float)
    Hy_arr = np.array(Hy_list, dtype=float)
    t_arr  = np.array(t_list, dtype=float)

    if len(t_arr) < 2:
        raise SystemExit("ERROR: Need at least two --points to build an interpolation.")

    # 1) Interpolate YOUR head angles with shortest-path, smooth behavior
    tt, Hx_interp = build_angle_interp(t_arr, Hx_arr, args.n_points)
    _,  Hy_interp = build_angle_interp(t_arr, Hy_arr, args.n_points)

    # 2) Convert your notation -> FOAM ABSOLUTE rotation angles
    #    Default upright model: H_x = 90° when rotX = 0°
    #    => rotX_abs = H_x - 90°
    Rx_abs = Hx_interp - 90.0
    Ry_abs = Hy_interp

    # 3) Extract initial ABSOLUTE orientation and make motion RELATIVE
    Rx0 = float(Rx_abs[0])
    Ry0 = float(Ry_abs[0])

    Rx_rel = Rx_abs - Rx0
    Ry_rel = Ry_abs - Ry0

    # Ensure output directory exists
    os.makedirs(args.output_dir, exist_ok=True)

    rot_path   = os.path.join(args.output_dir, "rotation.dat")
    trans_path = os.path.join(args.output_dir, "translation.dat")
    init_path  = os.path.join(args.output_dir, "initialOrientation.dat")

    write_rotation_dat(rot_path, tt, Rx_rel, Ry_rel, origin)
    write_translation_dat(trans_path, tt, origin)
    write_initial_orientation(init_path, Rx0, Ry0, origin)

    print(f"Wrote rotation.dat to          {rot_path}")
    print(f"Wrote translation.dat to       {trans_path}")
    print(f"Wrote initialOrientation.dat to {init_path}")
    print(
        f"Initial ABSOLUTE FOAM orientation (deg): "
        f"rotX0={Rx0:.3f}, rotY0={Ry0:.3f}, rotZ0=0.000"
    )
    print(
        f"Rotation centre (CoG) used: "
        f"({origin[0]:.3f}, {origin[1]:.3f}, {origin[2]:.3f})"
    )


if __name__ == "__main__":
    main()

